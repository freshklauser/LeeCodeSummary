



# 二分查找

## 模板汇总表

| 模板             | 1                                                  | 2                                                            | 3                                                            |
| ---------------- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 初始条件         | left = 0<br>right = length -1                      | left = 0<br>right = length                                   | left = 0<br>right = length - 1                               |
| 终止             | left > right                                       | left == right                                                | left + 1 == right                                            |
| 向左查找         | right = mid - 1                                    | right = mid                                                  | right = mid                                                  |
| 向右查找         | left = mid + 1                                     | left = mid + 1                                               | left = mid                                                   |
| 适用范围         | 查找可以通过访问数组中的单个索引来确定的元素或条件 | 访问数组中当前索引及其直接右邻居索引的元素或条件             | 搜索需要*访问当前索引及其在数组中的直接左右邻居索引*的元素或条件 |
| 后处理           | 无                                                 | 剩下 1 个元素时，结束 需**评估剩余的1个元素是否符合条件**    | 剩下2 个元素时结束需**评估剩余的1个元素是否符合条件**        |
| 边界比较         | 不需要与元素的两侧比较                             | 使用元素的右邻居来确定<br>是否满足条件，并决定是向左还是向右 | 使用直接左右邻居来确定它是向右还是向左                       |
| 查找空间元素个数 |                                                    | 保证查找空间在每一步中至少有 2 个元素                        | 保证查找空间在每一步中至少有 3个元素                         |

**模板分析：**

举例而言

1. 在严格递增有序数组中寻找某个数

2. **在有序数组中寻找某个数第一次出现的位置（或者在有序数组中寻找第一个大于等于某个数的位置）**

3. 已知有一个先严格递增后严格递减的数组，找数组最大值的位置

​    实际上在解题时，一般前两种模板就足够了（大部分应用第三种模板的情况都可以转化为前两种），第二种的模板和 Python 中 bisect.bisect() 类似。

## 模板1

**适用性**

- 用于查找可以通过*访问数组中的单个索引*来确定的元素或条件

**关键属性**

- 二分查找的最基础和最基本的形式。
- **查找条件可以在不与元素的两侧进行比较的情况下确定**（或使用它周围的特定元素） ---  <font color=red>区间左开右开</font>。
- 不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。

**区分语法**

- 初始条件：left = 0, right = length-1
- 终止：left > right
- 向左查找：right = mid-1
- 向右查找：left = mid+1

**标准示例**

```python
def binarySearch(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    # End Condition: left > right
    return -1
```



## 模板2

**适用性**

- 用于查找需要*访问数组中当前索引及其直接右邻居索引*的元素或条件（<font color=red>右边界查找</font>）

**关键属性**

- 一种实现二分查找的高级方法。
- **查找条件需要访问元素的直接右邻居** （<font color=red>区间左开右闭</font>）。
- 使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。
- **保证查找空间在每一步中至少有 2 个元素**。
- 需要进行**后处理**。 当你剩下 1 个元素时，循环 / 递归结束。 需要**评估剩余元素是否符合条件**。

**区分语法**

- 初始条件：left = 0, right = length
- 终止：left == right
- 向左查找：right = mid  
- 向右查找：left = mid+1

**标准示例**

```python
def binarySearch(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums)		# right = len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid

    # Post-processing:
    # End Condition: left == right
    if left != len(nums) and nums[left] == target:  # 由于right初始为len(nums)超出索引右边界，当right一直没改变的情况下，mid = len(nums) - 1时，left=right 也超出右边界，因此需要判断left是否超出右边界
        return left
    return -1

```



## 模板3

**适用性**

- 用于搜索需要*访问当前索引及其在数组中的直接左右邻居索引*的元素或条件 （<font color=red>左右边界</font>）

**关键属性**

- 实现二分查找的另一种方法。
- 搜索条件需要访问元素的直接左右邻居。
- 使用元素的邻居来确定它是向右还是向左。
- 保证查找空间在每个步骤中至少有 **3 个元素**。
- 需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。

**区分语法**

- 初始条件：left = 0, right = length-1
- 终止：left + 1 == right
- 向左查找：right = mid
- 向右查找：left = mid



# TODO

- [二分查找分析](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)